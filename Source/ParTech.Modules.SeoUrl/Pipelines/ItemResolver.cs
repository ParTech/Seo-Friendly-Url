namespace ParTech.Modules.SeoUrl.Pipelines
{
    using System;
    using System.Linq;
    using System.Net;
    using System.Web;
    using Sitecore;
    using Sitecore.Collections;
    using Sitecore.Data.Items;
    using Sitecore.Links;
    using Sitecore.Pipelines.HttpRequest;
    using Sitecore.SecurityModel;
    using Sitecore.Web;
    using ParTechProviders = ParTech.Modules.SeoUrl.Providers;

    /// <summary>
    /// HttpRequest processor that enables SEO-friendly URL's generated by the LinkProvider to be resolved to Sitecore items.
    /// </summary>
    public class ItemResolver : HttpRequestProcessor
    {
        /// <summary>
        /// Resolve the item with specified path by traversing the Sitecore tree
        /// </summary>
        /// <param name="path">Item path that is normalized by the SEO-friendly URL <see cref="ParTech.Modules.SeoUrl.Providers.LinkProvider"/>.</param>
        /// <returns></returns>
        public static Item ResolveItem(string path)
        {
            bool resolveComplete = false;

            // Only continue if the requested item belongs to the current site
            if (string.IsNullOrEmpty(Context.Site.RootPath) || !path.StartsWith(Context.Site.RootPath, StringComparison.InvariantCultureIgnoreCase))
            {
                return null;
            }

            // Strip website's rootpath from item path
            path = path.Remove(0, Context.Site.RootPath.Length);

            // If language embedding is enabled, there might be language name in front of the item path.
            // Strip the language prefix from the item path.
            if (Context.Language != null && (LinkManager.Provider.LanguageEmbedding == LanguageEmbedding.Always || LinkManager.Provider.LanguageEmbedding == LanguageEmbedding.AsNeeded))
            {
                string languagePrefix = string.Concat("/", Context.Language, "/").ToLower();

                // Remove the language code from the item path.
                if (path.StartsWith(languagePrefix, StringComparison.InvariantCultureIgnoreCase))
                {
                    path = path.Substring(languagePrefix.Length - 1);
                }
            }

            // Start searching from the site root
            string resolvedPath = Context.Site.RootPath;
            string[] itemNames = path.Split(new[] { '/' }, StringSplitOptions.RemoveEmptyEntries);

            for (int i = 0; i < itemNames.Length; i++)
            {
                string itemName = itemNames[i];

                if (!string.IsNullOrWhiteSpace(itemName))
                {
                    Item child = FindChild(resolvedPath, ParTechProviders.LinkProvider.Normalize(itemName));

                    if (child != null)
                    {
                        resolvedPath = child.Paths.FullPath;
                        resolveComplete = i == itemNames.Length - 1;
                    }
                    else
                    {
                        break;
                    }
                }
            }

            // Only return an item if we completely resolved the requested path
            if (resolveComplete)
            {
                return Context.Database.GetItem(resolvedPath);
            }

            return null;
        }

        /// <summary>
        /// Processes the specified HttpRequest pipeline arguments.
        /// </summary>
        /// <param name="args">The HttpRequest arguments.</param>
        public override void Process(HttpRequestArgs args)
        {
            // Set default values for apply and ignore sites.
            string[] applyForSites = { };
            string[] ignoreForSites = { "shell", "admin", "login" };

            // Try to get the apply/ignore site settings from the LinkProvider
            var provider = LinkManager.Provider as ParTechProviders.LinkProvider;

            if (provider != null)
            {
                applyForSites = provider.ApplyForSites;
                ignoreForSites = provider.IgnoreForSites;
            }

            // Ignore the ItemResolver if:
            // - The current site is in the ignore list.
            // - The current site is not in the apply list if apply list is not empty.
            // - There was a file found on disk for the current request.
            // - The context database is null.
            // - The context database is set to Core.
            if ((ignoreForSites != null && ignoreForSites.Contains(Context.Site.Name.ToLower()))
                || (applyForSites != null && !applyForSites.Contains(Context.Site.Name.ToLower()))
                || (Context.Page != null && !string.IsNullOrWhiteSpace(Context.Page.FilePath))
                || (Context.Database == null || Context.Database.Name.Equals("core", StringComparison.InvariantCultureIgnoreCase)))
            {
                return;
            }

            // Only continue if Sitecore has not found an item yet
            if (args != null && !string.IsNullOrEmpty(args.Url.ItemPath) && Context.Item == null)
            {
                Item resolved = null;

                // Resolve the item with security disabled.
                // Security will be applied after an item has been resolved.
                using (new SecurityDisabler())
                {
                    resolved = ResolveItem(args.Url.ItemPath);
                }

                if (resolved != null)
                {
                    // Use HttpRequestArgs.ApplySecurity to apply security.
                    // If read is not allowed, null is returned and args.PermissionDenied is set to true.
                    // This will trigger the default behavior of the Sitecore security handler.
                    Context.Item = args.ApplySecurity(resolved);
                }
            }

            // If the item was not requested using its SEO-friendly URL and is not a wildcard item, 301 redirect to force friendly URL.
            if (Context.Item != null && Context.PageMode.IsNormal && !Context.Item.Name.Equals("*"))
            {
                if (provider != null && provider.ForceFriendlyUrl)
                {
                    this.ForceFriendlyUrl(args);
                }
            }
        }

        /// <summary>
        /// Search the children of parentPath for one that matched the normalized item name
        /// </summary>
        /// <param name="parentPath"></param>
        /// <param name="normalizedItemName"></param>
        /// <returns></returns>
        private static Item FindChild(string parentPath, string normalizedItemName)
        {
            Item result = null;

            if (!string.IsNullOrWhiteSpace(parentPath))
            {
                ChildList children = Context.Database.GetItem(parentPath).Children;

                foreach (Item child in children)
                {
                    if (ParTechProviders.LinkProvider.Normalize(child.Name).Equals(normalizedItemName, StringComparison.InvariantCultureIgnoreCase)
                        || ParTechProviders.LinkProvider.Normalize(child.DisplayName).Equals(normalizedItemName, StringComparison.InvariantCultureIgnoreCase))
                    {
                        result = child;
                        break;
                    }
                }
            }

            return result;
        }

        /// <summary>
        /// Force items to be requested using their SEO-friendly URL.
        /// </summary>
        /// <remarks>
        /// Compares the requested URL with the friendly URL for the context item and 301 redirects
        /// to the friendly URL if it does not match the requested URL.
        /// </remarks>
        /// <param name="args">The HttpRequest arguments.</param>
        private void ForceFriendlyUrl(HttpRequestArgs args)
        {
            if (!HttpContext.Current.Request.HttpMethod.Equals("get", StringComparison.InvariantCultureIgnoreCase))
            {
                // Only force friendly URL's on GET requests.
                return;
            }

            // Get the raw request URL, which contains the original URL from before any internal rewrites have been performed,
            // and remove any querystring parameters.
            string rawRequestUrl = WebUtil.RemoveQueryString(args.Context.Request.RawUrl);

            // Get the relative path from the request URL.
            string requestedPath = ParTechProviders.LinkProvider.ToRelativeUrl(rawRequestUrl);

            // Get the relative path from the URL that is generated by the SEO-friendly LinkProvider.
            string friendlyPath = ParTechProviders.LinkProvider.ToRelativeUrl(LinkManager.GetItemUrl(Context.Item));

            // Verify that the request URL is equal to the friendly URL for the current item.
            // This ensures that content items are only accessible using one unique URL, avoiding possible "duplicate content" issues.
            if (requestedPath != friendlyPath)
            {
                // Redirect to the SEO-friendly URL with a permanent redirect.
                string friendlyUrl = string.Concat(LinkManager.GetItemUrl(Context.Item), args.Context.Request.Url.Query);

                this.RedirectPermanent(friendlyUrl);
            }
        }

        /// <summary>
        /// Permanently redirect to a URL using a 301 Moved Permanently header
        /// </summary>
        /// <param name="url"></param>
        private void RedirectPermanent(string url)
        {
            var context = HttpContext.Current;

            context.Response.Clear();
            context.Response.StatusCode = (int)HttpStatusCode.MovedPermanently;
            context.Response.RedirectLocation = url;

            // Add a header that indicates the redirect was a result of this module forcing a friendly URL.
            context.Response.AddHeader("X-SFUM-Redirect", "true");

            context.Response.End();
        }
    }
}